#!/usr/bin/env python3.4
# Marco Molteni, February 2015

"""
Simple script to generate a skeleton mock file and function for CppUMock.
It expects to be run in the directory containing the mocks.
"""

FILE_HEADER = '''
// autogenerated by mockify.py

extern "C" {
#include "@include@"
}

'''

import sys
import os.path
import textwrap

from pycparser import c_parser, c_ast


def main(args):
    if len(args) != 2:
        print("Usage: mockify mock_file mock_prototype")
        sys.exit(1)
    mock_filename = "{0}_mock.cpp".format(args[0])
    include_filename = "{0}.h".format(args[0])
    mock_prototype = args[1]
    print("working directory: " + os.getcwd())
    print("mock_filename: " + mock_filename)
    print("include_filename: " + include_filename)
    print("mock_prototype: " + mock_prototype)
    if os.path.exists(mock_filename):
        print("Mock file exists already")
        mock_file = open(mock_filename, "a")
    else:
        print("Creating mock file")
        mock_file = open(mock_filename, "w")
        write_header(mock_file, FILE_HEADER, include_filename)
    add_mock_function(mock_file, mock_prototype)
    mock_file.close()


def write_header(file, header, include):
    print("Adding file header")
    header = header.replace("@include@", include)
    file.write(header)


def add_mock_function(file, prototype):
    print("Adding mock function")
    # TODO: parse file to see if mock function is already there...
    mock_function = generate_mock_boilerplate(prototype)
    file.write("\n" + mock_function + "\n")


def generate_mock_boilerplate(prototype):
    # Thanks to cdecl.py from pycparser

    parser = c_parser.CParser()
    try:
        node = parser.parse(prototype)
    except c_parser.ParseError:
        e = sys.exc_info()[1]
        return "Parse error:" + str(e)
    if (not isinstance(node, c_ast.FileAST)
            or not isinstance(node.ext[-1], c_ast.Decl)):
        return "Not a valid declaration"
    decl = node.ext[-1]
    print("decl:"); decl.show(); print("")

    # storage is the optional "static" in "static void f();"
    storage = ''
    if decl.storage:
        storage = ' '.join(decl.storage)
    print("storage: " + storage + "\n")

    if not type(decl.type) == c_ast.FuncDecl:
        return "Error, not a function"

    func_decl = decl.type
    function_name = decl.name
    print("function_name: " + function_name + "\n")

    # func_decl.args : function arguments or None
    # func_decl.type : function type
    #func_decl.args.show()
    func_decl.type.show(); print("")

    # Simplest possible:
    # void f(); =>
    # void f() {
    #     mock().actualCall("f");
    # }

    if func_decl.type.type.names[0] == 'void':
        mock = textwrap.dedent(
            """
            {return_type} {function}({args}) {{
                mock().actualCall("{function}");
            }}
            """.format(return_type=func_decl.type.type.names[0],
                       function=function_name,
                       args="")).strip("\n")
        print(mock)
        return mock
    #
    # "withParameters" can only use int, double, const char* or const void*
    # void f(int i, const char* p); =>
    # void f(int i, const char* p) {
    #     mock().actualCall("f")
    #         .withParameter("i", i)
    #         .withParameter("p", p);
    # }
    #
    # Output parameters:
    #
    # void Foo(int *bar)
    # {
    #     mock().actualCall("foo").
    #         withOutputParameter("bar", bar);
    # }
    #
    # Return values:
    #
    # int function () {
    #     mock().actualCall("function");
    #     if (mock.hasxxx) {
    #         return mock().intReturnValue();
    #     }
    #     return WRITEME;
    # }
    #
    #


if __name__ == "__main__":
    main(sys.argv[1:])
