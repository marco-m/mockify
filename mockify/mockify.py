#!/usr/bin/env python3.4
# Marco Molteni, February 2015

"""
Simple script to generate a skeleton mock file and function for CppUMock.
It expects to be run in the directory containing the mocks.
"""

FILE_HEADER = '''
// autogenerated by mockify.py

extern "C" {
#include "@include@"
}

'''

import sys
import os.path


def main(args):
    if len(args) != 2:
        print("Usage: mockify mock_file mock_prototype")
        sys.exit(1)
    mock_filename = "{0}_mock.cpp".format(args[0])
    include_filename = "{0}.h".format(args[0])
    mock_prototype = args[1]
    print("working directory: " + os.getcwd())
    print("mock_filename: " + mock_filename)
    print("include_filename: " + include_filename)
    print("mock_prototype: " + mock_prototype)
    if os.path.exists(mock_filename):
        print("Mock file exists already")
        mock_file = open(mock_filename, "a")
    else:
        print("Creating mock file")
        mock_file = open(mock_filename, "w")
        write_header(mock_file, FILE_HEADER, include_filename)
    add_mock_function(mock_file, mock_prototype)
    mock_file.close()


def write_header(file, header, include):
    print("Adding file header")
    header = header.replace("@include@", include)
    file.write(header)


def add_mock_function(file, prototype):
    print("Adding mock function")
    # TODO: parse file to see if mock function is already there...
    mock_function = generate_mock_boilerplate(prototype)
    file.write("\n" + mock_function + "\n")


def generate_mock_boilerplate(prototype):
    # Two cases: returns void or returns something.
    # If it returns something, add also boilerplate for test-injected value.
    #
    # Simplest possible:
    # void f(); =>
    # void f() {
    #     mock().actualCall("f");
    # }
    #
    # "withParameters" can only use int, double, const char* or void*
    # void f(int i, const char* p); =>
    # void f(int i, const char* p) {
    #     mock().actualCall("f")
    #         .withParameter("i", i)
    #         .withParameter("p", p);
    # }
    #
    # Output parameters:
    #
    # void Foo(int *bar)
    # {
    #     mock().actualCall("foo").
    #         withOutputParameter("bar", bar);
    # }
    #
    # Return values:
    #
    # int function () {
    #     mock().actualCall("function");
    #     if (mock.hasxxx) {
    #         return mock().intReturnValue();
    #     }
    #     return WRITEME;
    # }
    #
    # or maybe (check if it works):
    # int function () {
    #     mock().actualCall("function");
    #     return mock().returnIntValueOrDefault(WRITEME);
    # }
    #
    # int f(int i, const char* p);
    # char* f(int i, char *p);
    # char * f(int i, char * p);
    #
    return "WRITEME"


if __name__ == "__main__":
    main(sys.argv[1:])
